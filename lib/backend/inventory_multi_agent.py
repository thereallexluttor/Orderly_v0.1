from phi.workflow import Workflow
from phi.agent import Agent
from phi.model.google import Gemini
from typing import Dict, Any, Optional
from pydantic import Field
import logging
import os
from dotenv import load_dotenv
import numpy as np
from scipy import stats
import pandas as pd
from statsmodels.tsa.seasonal import seasonal_decompose
import json

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Cargar variables de entorno
load_dotenv()
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")

if not GOOGLE_API_KEY:
    raise ValueError("GOOGLE_API_KEY no est치 configurada en las variables de entorno")

def convert_numpy_types(obj):
    """Convierte tipos de NumPy a tipos nativos de Python"""
    if isinstance(obj, np.integer):
        return int(obj)
    elif isinstance(obj, np.floating):
        return float(obj)
    elif isinstance(obj, np.ndarray):
        return obj.tolist()
    return obj

class InventoryAnalysisSystem(Workflow):
    analyst: Optional[Agent] = Field(default=None)
    advisor: Optional[Agent] = Field(default=None)

    def __init__(self):
        super().__init__()
        logger.info("Inicializando sistema de an치lisis t칠cnico de inventario...")
        gemini_model = Gemini(api_key=GOOGLE_API_KEY)
        self._initialize_agents(gemini_model)

    def _initialize_agents(self, model):
        """Inicializa los agentes de an치lisis"""
        try:
            self.analyst = Agent(
                name="DataAnalyst",
                role="Analista especializado en detecci칩n de riesgos de inventario y patrones de consumo",
                model=Gemini(id="gemini-1.5-flash"),
                description="Analizo patrones cr칤ticos de consumo y genero alertas tempranas de desabastecimiento",
                instructions=[
                    "Identificar INMEDIATAMENTE cualquier riesgo de desabastecimiento",
                    "Calcular agresivamente puntos de reorden y niveles cr칤ticos de stock",
                    "Detectar y reportar urgentemente patrones anormales de consumo",
                    "Generar alertas cuando el consumo supere 2 desviaciones est치ndar",
                    "Priorizar an치lisis de ingredientes con mayor impacto en operaciones",
                    "Calcular probabilidades espec칤ficas de desabastecimiento",
                    "Identificar desperdicios y sobrestock con m칠tricas precisas",
                    "Agregar niveles de urgencia (游댮CR칈TICO, 游리PRECAUCI칍N, 游릭NORMAL) a cada hallazgo"
                ],
            )

            self.advisor = Agent(
                name="AdvancedAnalyst",
                role="Estratega matem치tico para an치lisis avanzado de inventario",
                model=Gemini(id="gemini-1.5-flash"),
                description="Realizo an치lisis matem치ticos y estad칤sticos avanzados para optimizar inventario",
                instructions=[
                    "Realiza an치lisis avanzados basados puramente en estad칤sticas y matem치ticas.",
                    "Explora correlaciones, regresiones lineales y no lineales entre variables del inventario.",
                    "Identifica patrones estacionales o tendencias utilizando series temporales.",
                    "Eval칰a la fuerza y significancia de los patrones detectados, usando m칠tricas estad칤sticas como R^2 o p-value.",
                    "Prop칩n acciones basadas en el an치lisis matem치tico, priorizando datos objetivos y m칠tricas derivadas.",
                    "Calcula intervalos de confianza para proyecciones de inventario.",
                    "Detecta comportamientos an칩malos en las m칠tricas analizadas (z-score, IQR, etc.).",
                    "Genera m칠tricas avanzadas para evaluar la estabilidad y confiabilidad del inventario."
                ],
            )
            
        except Exception as e:
            logger.error(f"Error en inicializaci칩n: {str(e)}", exc_info=True)
            raise

    def _perform_statistical_analysis(self, history_data: list) -> dict:
        """Realiza an치lisis estad칤stico detallado de los datos hist칩ricos"""
        try:
            # Convertir datos hist칩ricos a DataFrame
            df = pd.DataFrame(history_data)
            df['created_at'] = pd.to_datetime(df['created_at'])
            df = df.set_index('created_at').sort_index()
            
            # An치lisis de series temporales
            usage_series = df['quantity']
            
            # Descomposici칩n de la serie temporal
            decomposition = seasonal_decompose(usage_series, period=7, model='additive')
            
            # Calcular estad칤sticas descriptivas
            stats_analysis = {
                "mean": usage_series.mean(),
                "median": usage_series.median(),
                "std": usage_series.std(),
                "cv": usage_series.std() / usage_series.mean() * 100,
                "skewness": stats.skew(usage_series),
                "kurtosis": stats.kurtosis(usage_series),
                "trend_slope": np.polyfit(range(len(usage_series)), usage_series, 1)[0],
                "seasonality_strength": np.std(decomposition.seasonal) / np.std(usage_series),
                "autocorrelation": usage_series.autocorr(),
            }
            
            # Detecci칩n de anomal칤as
            z_scores = np.abs(stats.zscore(usage_series))
            anomalies = (z_scores > 3).sum()
            stats_analysis["anomalies_count"] = anomalies
            
            return stats_analysis
            
        except Exception as e:
            logger.error(f"Error en an치lisis estad칤stico: {str(e)}", exc_info=True)
            return {}

    def analyze_inventory_global(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Ejecuta el workflow de an치lisis global de inventario"""
        try:
            # Calcular estad칤sticas globales
            all_stats = []
            for ingredient in context['ingredients']:
                stats = self._perform_statistical_analysis(ingredient['history'])
                stats['ingredient_name'] = ingredient['ingredient_name']
                all_stats.append(stats)

            # Convertir a tipos nativos de Python
            all_stats = [{k: convert_numpy_types(v) for k, v in stats.items()} 
                        for stats in all_stats]

            # Prompt para an치lisis global
            analysis_prompt = f"""
            AN츼LISIS GLOBAL DEL INVENTARIO

            Datos generales:
            - Total de ingredientes: {len(context['ingredients'])}
            - Ingredientes en estado cr칤tico: {sum(1 for i in context['ingredients'] if i['stock_status'] == 'cr칤tico')}
            - Ingredientes en estado normal: {sum(1 for i in context['ingredients'] if i['stock_status'] == 'normal')}

            ESTAD칈STICAS POR INGREDIENTE:
            {json.dumps(all_stats, indent=2)}

            DATOS DE INVENTARIO ACTUAL:
            {json.dumps([{
                'nombre': i['ingredient_name'],
                'stock_actual': i['current_stock'],
                'stock_total': i['total_stock'],
                'unidad': i['unit'],
                'uso_promedio': i['average_daily_usage'],
                'uso_m치ximo': i['max_daily_usage']
            } for i in context['ingredients']], indent=2)}

            Realiza un an치lisis global del inventario considerando:
            1. Patrones generales de uso entre ingredientes
            2. Correlaciones entre diferentes ingredientes
            3. Identificaci칩n de grupos de ingredientes con comportamiento similar
            4. An치lisis de riesgos y puntos cr칤ticos
            5. Tendencias globales del inventario

            Proporciona un an치lisis puramente estad칤stico, matematico y analitico basado en los datos.
            """

            analysis = self.analyst.run(analysis_prompt)

            # Prompt para recomendaciones globales
            recommendations_prompt = f"""
            AN츼LISIS PREVIO:
            {analysis.content if hasattr(analysis, 'content') else str(analysis)}

            DATOS ADICIONALES:
            {json.dumps(context, indent=2)}

            Bas치ndote en el an치lisis anterior, proporciona recomendaciones puramente matem치ticas y estad칤sticas usando los datos que tienes disponibles sobre
            los ingredientes tales como:
            1. C칩mo clasificar ingredientes seg칰n su estabilidad (usando coeficiente de variaci칩n y desviaci칩n est치ndar).
            2. M칠todos para identificar patrones comunes usando clustering o an치lisis de componentes principales (PCA).
            3. Identificaci칩n de series temporales no estacionarias y sugerencias para estabilizarlas.
            4. Proyecciones para los pr칩ximos 30 d칤as con intervalos de confianza (ej.: 95%).
            5. Acciones concretas para mejorar la precisi칩n del an치lisis de tendencias.
            """

            recommendations = self.advisor.run(recommendations_prompt)

            return {
                "status": "success",
                "analysis": analysis.content if hasattr(analysis, 'content') else str(analysis),
                "recommendations": recommendations.content if hasattr(recommendations, 'content') else str(recommendations),
                "statistical_data": all_stats
            }

        except Exception as e:
            logger.error(f"Error en an치lisis global: {str(e)}", exc_info=True)
            return {
                "status": "error",
                "message": str(e),
                "analysis": "Error en an치lisis estad칤stico global",
                "recommendations": "Error en recomendaciones globales"
            }
